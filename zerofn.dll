#include <Windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <wininet.h>
#include <urlmon.h>
#include <detours.h>
#include <sstream>
#include <fstream>
#include <TlHelp32.h>

#pragma comment(lib, "wininet.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "detours.lib")

// Function pointer types for hooks
typedef BOOL(WINAPI* tHttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
typedef HINTERNET(WINAPI* tHttpOpenRequestA)(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR* lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
typedef HINTERNET(WINAPI* tInternetConnectA)(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
typedef BOOL(WINAPI* tHttpSendRequestW)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
typedef HINTERNET(WINAPI* tHttpOpenRequestW)(HINTERNET hConnect, LPCWSTR lpszVerb, LPCWSTR lpszObjectName, LPCWSTR lpszVersion, LPCWSTR lpszReferrer, LPCWSTR* lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
typedef HINTERNET(WINAPI* tInternetConnectW)(HINTERNET hInternet, LPCWSTR lpszServerName, INTERNET_PORT nServerPort, LPCWSTR lpszUserName, LPCWSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);

// Original function pointers
tHttpSendRequestA originalHttpSendRequestA = nullptr;
tHttpOpenRequestA originalHttpOpenRequestA = nullptr;
tInternetConnectA originalInternetConnectA = nullptr;
tHttpSendRequestW originalHttpSendRequestW = nullptr;
tHttpOpenRequestW originalHttpOpenRequestW = nullptr;
tInternetConnectW originalInternetConnectW = nullptr;

// Custom backend URL
const char* BACKEND_URL = "127.0.0.1";
const wchar_t* BACKEND_URL_W = L"127.0.0.1";
const INTERNET_PORT BACKEND_PORT = 8080; 

// Helper function to log requests
void LogRequest(const char* type, const char* url) {
    std::ofstream log("zerofn_requests.log", std::ios::app);
    if (log.is_open()) {
        log << type << ": " << url << std::endl;
        log.close();
    }
}

// Hooked functions
BOOL WINAPI HookedHttpSendRequestA(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength) {
    LogRequest("SendRequestA", lpszHeaders ? lpszHeaders : "No Headers");
    return originalHttpSendRequestA(hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength);
}

BOOL WINAPI HookedHttpSendRequestW(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength) {
    if (lpszHeaders) {
        std::wstring headers(lpszHeaders);
        LogRequest("SendRequestW", std::string(headers.begin(), headers.end()).c_str());
    }
    return originalHttpSendRequestW(hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength);
}

HINTERNET WINAPI HookedHttpOpenRequestA(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR* lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext) {
    dwFlags |= INTERNET_FLAG_IGNORE_CERT_CN_INVALID | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID;
    dwFlags &= ~INTERNET_FLAG_SECURE;
    return originalHttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext);
}

HINTERNET WINAPI HookedHttpOpenRequestW(HINTERNET hConnect, LPCWSTR lpszVerb, LPCWSTR lpszObjectName, LPCWSTR lpszVersion, LPCWSTR lpszReferrer, LPCWSTR* lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext) {
    dwFlags |= INTERNET_FLAG_IGNORE_CERT_CN_INVALID | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID;
    dwFlags &= ~INTERNET_FLAG_SECURE;
    return originalHttpOpenRequestW(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext);
}

HINTERNET WINAPI HookedInternetConnectA(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext) {
    if (strstr(lpszServerName, "epicgames.com") || 
        strstr(lpszServerName, "fortnite.com") || 
        strstr(lpszServerName, "ol.epicgames.com")) {
        LogRequest("Redirecting", lpszServerName);
        return originalInternetConnectA(hInternet, BACKEND_URL, BACKEND_PORT, lpszUserName, lpszPassword, dwService, dwFlags, dwContext);
    }
    return originalInternetConnectA(hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext);
}

HINTERNET WINAPI HookedInternetConnectW(HINTERNET hInternet, LPCWSTR lpszServerName, INTERNET_PORT nServerPort, LPCWSTR lpszUserName, LPCWSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext) {
    std::wstring serverName(lpszServerName);
    if (serverName.find(L"epicgames.com") != std::wstring::npos || 
        serverName.find(L"fortnite.com") != std::wstring::npos || 
        serverName.find(L"ol.epicgames.com") != std::wstring::npos) {
        return originalInternetConnectW(hInternet, BACKEND_URL_W, BACKEND_PORT, lpszUserName, lpszPassword, dwService, dwFlags, dwContext);
    }
    return originalInternetConnectW(hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext);
}

// Export a function that can be called from the launcher to verify injection
extern "C" __declspec(dllexport) BOOL WINAPI VerifyInjection() {
    return TRUE;
}

// Helper function to wait for Fortnite process to be fully initialized
void WaitForFortniteInit() {
    Sleep(2000); // Reduced initial wait
    
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());
    if (snapshot != INVALID_HANDLE_VALUE) {
        MODULEENTRY32W me32;
        me32.dwSize = sizeof(MODULEENTRY32W);
        
        if (Module32FirstW(snapshot, &me32)) {
            do {
                if (wcsstr(me32.szModule, L"FortniteClient-Win64-Shipping.exe")) {
                    CloseHandle(snapshot);
                    return;
                }
            } while (Module32NextW(snapshot, &me32));
        }
        CloseHandle(snapshot);
    }
}

extern "C" __declspec(dllexport) BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH: {
            DisableThreadLibraryCalls(hModule);

            // Wait for Fortnite to initialize
            WaitForFortniteInit();

            // Create console for logging
            AllocConsole();
            FILE* f;
            freopen_s(&f, "CONOUT$", "w", stdout);
            std::cout << "ZeroFN DLL Injection Started..." << std::endl;

            // Load wininet.dll
            HMODULE hWininet = LoadLibraryA("wininet.dll");
            if (!hWininet) {
                std::cout << "Failed to load wininet.dll" << std::endl;
                return FALSE;
            }

            // Get function addresses
            originalHttpSendRequestA = (tHttpSendRequestA)GetProcAddress(hWininet, "HttpSendRequestA");
            originalHttpOpenRequestA = (tHttpOpenRequestA)GetProcAddress(hWininet, "HttpOpenRequestA");
            originalInternetConnectA = (tInternetConnectA)GetProcAddress(hWininet, "InternetConnectA");
            originalHttpSendRequestW = (tHttpSendRequestW)GetProcAddress(hWininet, "HttpSendRequestW");
            originalHttpOpenRequestW = (tHttpOpenRequestW)GetProcAddress(hWininet, "HttpOpenRequestW");
            originalInternetConnectW = (tInternetConnectW)GetProcAddress(hWininet, "InternetConnectW");

            if (!originalHttpSendRequestA || !originalHttpOpenRequestA || !originalInternetConnectA ||
                !originalHttpSendRequestW || !originalHttpOpenRequestW || !originalInternetConnectW) {
                std::cout << "Failed to get function addresses" << std::endl;
                return FALSE;
            }

            // Attach hooks
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());

            DetourAttach(&(PVOID&)originalHttpSendRequestA, HookedHttpSendRequestA);
            DetourAttach(&(PVOID&)originalHttpOpenRequestA, HookedHttpOpenRequestA);
            DetourAttach(&(PVOID&)originalInternetConnectA, HookedInternetConnectA);
            DetourAttach(&(PVOID&)originalHttpSendRequestW, HookedHttpSendRequestW);
            DetourAttach(&(PVOID&)originalHttpOpenRequestW, HookedHttpOpenRequestW);
            DetourAttach(&(PVOID&)originalInternetConnectW, HookedInternetConnectW);

            LONG error = DetourTransactionCommit();
            if (error != NO_ERROR) {
                std::cout << "Failed to attach hooks: " << error << std::endl;
                return FALSE;
            }

            std::cout << "ZeroFN DLL Injection Complete!" << std::endl;
            break;
        }

        case DLL_PROCESS_DETACH: {
            // Clean up hooks
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());

            DetourDetach(&(PVOID&)originalHttpSendRequestA, HookedHttpSendRequestA);
            DetourDetach(&(PVOID&)originalHttpOpenRequestA, HookedHttpOpenRequestA);
            DetourDetach(&(PVOID&)originalInternetConnectA, HookedInternetConnectA);
            DetourDetach(&(PVOID&)originalHttpSendRequestW, HookedHttpSendRequestW);
            DetourDetach(&(PVOID&)originalHttpOpenRequestW, HookedHttpOpenRequestW);
            DetourDetach(&(PVOID&)originalInternetConnectW, HookedInternetConnectW);

            DetourTransactionCommit();
            break;
        }
    }
    return TRUE;
}
